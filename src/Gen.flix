
mod Gen {
    // use Monad.{>>=}
    use SplittableRandom.{split, nextBool, nextInt32, nextFloat64}

    pub type alias Rand = SplittableRandom

        pub enum Gen[a: Type, r: Region](
        Int32 -> Region[r] -> Rand[r] -> a \ r
    )

    // Did not work for the original Functor, so we made our own
    /// Functor trait that works for Gen
    pub trait Functor[m: Type -> Eff -> Type] {
        pub def map(f: a -> b \ ef, x: m[a, r]): m[b, r] \ ef
    }

    pub trait Applicative[m: Type -> Eff -> Type] with Functor[m] {
        pub def ap(f: m[a -> b \ ef, r], x: m[a, r]): m[b, r] \ ef
        pub def point(x: a): m[a, r]
    }

    pub trait Monad[m: Type -> Eff -> Type] with Applicative[m] {
        /// Returns a generator that generates a value of type `b` by applying the function generated by `fGen` to the value generated by `aGen`.
        pub def flatMap(f: a -> m[b, r] \ ef, x: m[a, r]): m[b, r] \ ef
    }

    // Using selfdefined Functor
    instance Functor[Gen] {
        pub def map(f: a -> b \ ef, gen: Gen[a, r]): Gen[b, r] \ ef =
            checked_ecast(Gen.Gen(size -> rc -> rand -> 
                unchecked_cast(f(applyGen(gen, size, rc, rand)) as _ \ r)))
    }

    instance Applicative[Gen] {
        /// Returns a generator that generates a value of type `b` by applying the function generated by `fGen` to the value generated by `aGen`.
        pub def ap(fGen: Gen[a -> b \ ef, r], aGen: Gen[a, r]): Gen[b, r] \ ef = 
            checked_ecast(Gen.Gen(size -> rc -> rand ->
                let (r1, r2) = split(rand); 
                let func = applyGen(fGen, size, rc, r1);
                unchecked_cast(func(applyGen(aGen, size, rc, r2)) as _ \ r)))
        
        /// Returns a generator that generates a value of the given type
        pub def point(x: a): Gen[a, r] = 
            return(x)
    }

    instance Monad[Gen] {
        pub def flatMap(f: a -> Gen[b, r] \ ef, aGen: Gen[a, r]): Gen[b, r] \ ef =             
            checked_ecast(Gen.Gen(size -> rc -> rand -> 
                let (r1, r2) = split(rand);
                unchecked_cast(
                    let Gen.Gen(func) = f(applyGen(aGen, size, rc, r1));
                    func(size, rc, r2) as _ \ r))
            )
    }

    pub def map2(f: (a -> b -> c), x: Gen[a, r] , y: Gen[b, r]): Gen[c, r] =
        Applicative.ap(Functor.map(f, x), y)    

    pub def map3(f: (a -> b -> c -> d), x: Gen[a, r], y: Gen[b, r], z: Gen[c, r]): Gen[d, r] =
        Applicative.ap(map2(f, x, y), z)

    pub def map4(f: (a -> b -> c -> d -> e), x: Gen[a, r], y: Gen[b, r], z: Gen[c, r], w: Gen[d, r]): Gen[e, r] =
        Applicative.ap(map3(f, x, y, z), w)

    pub def >>=(x: Gen[a, r], f: a -> Gen[b, r]): Gen[b, r] =
        Monad.flatMap(f, x) 

    /// Returns a generator with of the type `a` and the effect r.
    pub def return(x: a): Gen[a, r] = 
        Gen.Gen(_ -> _ -> _ -> unchecked_cast(x as _ \ r))

    pub def applyGen(gen: Gen[a, r], size: Int32, rc: Region[r], rand: Rand[r]): a \ r =
        match gen {
            case Gen.Gen(g) => g(size, rc, rand)
        }
    
    /// Returns a generator that generates a value of type `a` in the interval size defines.
    pub def sized(f: Int32 -> Gen[a, r]): Gen[a, r] = 
        Gen.Gen(size -> reg -> rand ->
            applyGen(f(size), size, reg, rand)
        )

    pub def regioned(f: Region[r] -> Gen[a, r]): Gen[a, r] = 
        Gen.Gen(size -> reg -> rand ->
            applyGen(f(reg), size, reg, rand)
        )

    /// Makes sure that the generator uses the specified size.
    /// 
    /// Takes as input size and generator of type `a`.     
    ///
    /// Returns a generator that generates a value of type `a`.
    pub def resize(size: Int32, gen: Gen[a, r]): Gen[a, r] = 
        Gen.Gen(_ -> rand -> 
            applyGen(gen, size, rand)
        )

    pub def rand(): Gen[Rand[r], r] = 
        Gen.Gen(_ -> _ -> rand -> unchecked_cast(rand as _ \ r))
    
    /// Returns a generator that generates a value of type `a` from the given non-empty list of generators.
    pub def elements(xs: Nel[a]): Gen[a, r] =
        let vec = Nel.toVector(xs);
        Functor.map(index -> Vector.get(index, vec), chooseInt(0, Vector.length(vec) - 1))

    /// Returns a generator that generates a list of values of type `a` of length `n`.
    ///
    /// `n` is the length of the list.
    pub def vector(length: Int32): Gen[List[a], r] with Arbitrary[a] =
        let gens: List[Gen[a, r]] = List.map(_ -> Arbitrary.arbitrary(), List.range(0, length));
        sequence(gens)

    /// Returns a generator that generates a list of length `length` with values of type `a`.
    pub def sizedListOf(length: Int32, gen: Gen[a, r]): Gen[List[a], r] =
        let gens: List[Gen[a, r]] = List.map(_ -> gen, List.range(0, length));
        sequence(gens)
        
    // Modified sequence from List.sequence
    pub def sequence(l: List[Gen[a, r]]): Gen[List[a], r] =
        def loop(ll, k) = match ll {
            case Nil => k(Applicative.point(Nil)),
            case mx :: rs => loop(rs, ks -> k(consA(mx, ks)))
        };
        loop(l, identity)
        
    // Modified consA from List.sequence
    pub def consA(mx: Gen[a, r], ml: Gen[List[a], r]): Gen[List[a], r] =
        Applicative.ap(Functor.map((x, xs) -> x :: xs, mx), ml)  

    /// Returns a generator that generates a list of length `length` with values of type `a` in ascending order.
    pub def orderedListOf(length: Int32, gen: Gen[a, r]): Gen[List[a], r] with Order[a] =
        Functor.map(List.sort, sizedListOf(length, gen))

    /// Returns a generator that generates a value of type `a` from the given non-empty list of generators.
    pub def oneOf(gens: Nel[Gen[a, r]]): Gen[a, r] =
        elements(gens) >>= (x -> x)

    /// Returns a randomly generated value of type `a` based on the given frequencies.
    ///
    /// `xs`: A non-empty list of pairs, where each pair consists of an integer frequency and a generator for values of type `a`.
    ///
    /// Returns a generator of type `a`.
    pub def frequency(xs: Nel[(Int32, Gen[a, r])]): Gen[a, r] =
        let total = Nel.foldLeft((acc, x) -> acc + fst(x), 0, xs);
        chooseInt(1, total) >>= (n -> pick(n, xs))

    /// Returns a randomly generated value of type `a` based on the given frequency distribution.
    ///
    /// `n` is the number used to select a generator based on its frequency.
    ///
    /// `nel` is the non-empty list of tuples containing frequencies and generators.
    ///
    /// Returns a randomly generated value of type `a`.
    pub def pick(n: Int32, nel: Nel[(Int32, Gen[a, r])]): Gen[a, r] =
        match nel {
            case Nel.Nel((k, gen), _) if (n <= k) => 
                gen,
            case Nel.Nel((k, _), y :: ys) =>
                pick(n-k, Nel.Nel(y, ys))
            case Nel.Nel((_, _), Nil) =>
                // This should never happen as the sum of all frequencies are equal to n.
                unreachable!()
        }

    /// Returns a Generator that uniformly generates values in the interval [lower, upper]
    pub def chooseInt(lower: Int32, upper: Int32): Gen[Int32, r] =
        Gen.Gen(_ -> _ -> rand ->
            nextInt32(rand, lower, upper + 1)
        )

    /// Returns a generator that uniformly generates a boolean value.
    pub def chooseBool(): Gen[Bool, r] =
        Gen.Gen(_ -> _ -> rand ->
            nextBool(rand)
        )

    /// Returns a generator that uniformly generates a float value in the interval [lower, upper]
    pub def chooseFloat(lower: Float64, upper: Float64): Gen[Float64, r] =
        Gen.Gen(_ -> _ -> rand ->
            nextFloat64(rand, lower, upper)
        )

    /// Returns a generator that uniformly generates a lower case character.
    pub def chooseLowerChar(): Gen[Char, r] =
        elements(Nel.Nel('a', 
        'b' :: 'c' :: 'd' :: 'e' :: 'f' :: 'g' :: 'h' :: 
        'i' :: 'j' :: 'k' :: 'l' :: 'm' :: 'n' :: 'o' :: 
        'p' :: 'q' :: 'r' :: 's' :: 't' :: 'u' :: 'v' :: 
        'w' :: 'x' :: 'y' :: 'z' :: Nil))
        
    /// Returns a generator that uniformly generates an upper case character.    
    pub def chooseUpperChar(): Gen[Char, r] =
        elements(Nel.Nel('A', 
        'B' :: 'C' :: 'D' :: 'E' :: 'F' :: 'G' :: 'H' ::
        'I' :: 'J' :: 'K' :: 'L' :: 'M' :: 'N' :: 'O' ::
        'P' :: 'Q' :: 'R' :: 'S' :: 'T' :: 'U' :: 'V' ::
        'W' :: 'X' :: 'Y' :: 'Z' :: Nil))

    /// Returns a generator that uniformly generates a string of length `size` with characters generated by `gen`.
    pub def chooseString(size: Int32, gen: Gen[Char, r]): Gen[String, r] =
        match size {
            case _ if size <= 0 => 
                return(""),
            case _ => 
                map2((c, s) -> Char.toString(c) + s, gen, chooseString(size-1, gen))
        }
        

    /// Arbitrary trait 
    pub trait Arbitrary[a] {
        pub def arbitrary(): Gen[a, r]
    }

    // /// Arbitrary instance for the unit type.
    // instance Arbitrary[Unit] {
    //     pub def arbitrary(): Gen[Unit, r] =
    //         Applicative.point()
    // }

    /// Arbitrary instance for the Int32 type.
    instance Arbitrary[Int32] {
        pub def arbitrary(): Gen[Int32, r] =
            sized(size -> chooseInt(-size, size))
    }

    // /// Arbitrary instance for the Bool type.
    // instance Arbitrary[Bool] {
    //     pub def arbitrary(): Gen[Bool, r] =
    //         chooseBool()
    // }

    // /// Arbitrary instance for the Char type.
    // instance Arbitrary[Char] {
    //     pub def arbitrary(): Gen[Char, r] = 
    //         chooseUpperChar()
    // }

    // /// Arbitrary instance for the Float64 type.
    // instance Arbitrary[Float64] {
    //     pub def arbitrary(): Gen[Float64, r] = 
    //         sized(size -> chooseFloat(Int32.toFloat64(-size), Int32.toFloat64(size)))
    // }

    // /// Arbitrary instance for the String type.
    // instance Arbitrary[String] {
    //     pub def arbitrary(): Gen[String, r] =
    //         sized(size ->
    //             chooseInt(0, size) >>= (x -> chooseString(x, chooseLowerChar()))
    //         )
    // }

    // /// Arbitrary instance for tuples
    // instance Arbitrary[(a, b)] with Arbitrary[a], Arbitrary[b] {
    //     pub def arbitrary(): Gen[(a, b), r] =
    //         map2((x, y) -> (x, y), Arbitrary.arbitrary(), Arbitrary.arbitrary())
    // }

    // /// Arbitrary instance for triples
    // instance Arbitrary[(a, b, c)] with Arbitrary[a], Arbitrary[b], Arbitrary[c] {
    //     pub def arbitrary(): Gen[(a, b, c), r] =
    //         map3((x, y, z) -> (x, y, z), Arbitrary.arbitrary(), Arbitrary.arbitrary(), Arbitrary.arbitrary())
    // }

    // /// Arbitrary instance for quadruples
    // instance Arbitrary[(a, b, c, d)] with Arbitrary[a], Arbitrary[b], Arbitrary[c], Arbitrary[d] {
    //     pub def arbitrary(): Gen[(a, b, c, d), r] =
    //         map4((w, x, y, z) -> (w, x, y, z), Arbitrary.arbitrary(), Arbitrary.arbitrary(), Arbitrary.arbitrary(), Arbitrary.arbitrary())
    // }

    /// Arbitrary instance for for the List type.
    instance Arbitrary[List[a]] with Arbitrary[a] {
        pub def arbitrary(): Gen[List[a], r] =
            sized(size ->
                chooseInt(0, size) >>= vector
            )
    }

    // /// Arbitrary instance for the Non Empty List (Nel) type.
    // instance Arbitrary[Nel[a]] with Arbitrary[a] {
    //     type Elm[Nel[a]] = Nel[a]
    //     type Aef = {}
    //     pub def arbitrary(): Gen[Nel[a], r] =
    //         // map2((x, xs) -> Nel.Nel(x, xs), Arbitrary.arbitrary(), vector(5 - 1))
    //         sized(size ->
    //             map2((x, xs) -> Nel.Nel(x, xs), Arbitrary.arbitrary(), vector(size - 1))
    //         )
    // }

    // /// Arbitrary instance for the Chain type.
    // instance Arbitrary[Chain[a]] with Arbitrary[a] {
    //     type Elm[Chain[a]] = Chain[a]
    //     type Aef = {}
    //     pub def arbitrary(): Gen[Chain[a], r] =
    //         sized(size ->
    //             Functor.map(List.toChain, vector(size))
    //         )
    // }

    // /// Arbitrary instance for the Non Empty Chain (Nec) type.
    // instance Arbitrary[Nec[a]] with Arbitrary[a] {
    //     type Elm[Nec[a]] = Nec[a]
    //     type Aef = {}
    //     pub def arbitrary(): Gen[Nec[a], r] =
    //         let func = (x, xs) -> 
    //             match List.toNec(xs) {
    //                 case None => Nec.singleton(x),
    //                 case Some(tail) => Nec.append(Nec.singleton(x), tail)
    //         };
    //         sized(size -> map2(func, Arbitrary.arbitrary(), vector(size - 1)))
    // }

    // /// Arbitrary instance for the Vector type.
    // instance Arbitrary[Vector[a]] with Arbitrary[a] {
    //     type Elm[Vector[a]] = Vector[a]
    //     type Aef = {}
    //     pub def arbitrary(): Gen[Vector[a], r] =
    //         sized(size -> 
    //             Functor.map(List.toVector, vector(size))
    //         )
    // }

    // /// Arbitrary instance for the Option type.
    // instance Arbitrary[Option[a]] with Arbitrary[a] {
    //     pub def arbitrary(): Gen[Option[a], r] = 
    //         let func = (bool, arb) ->
    //             match bool {
    //                 case true => Some(arb),
    //                 case false => None
    //             };
    //         map2(func, chooseBool(), Arbitrary.arbitrary())
    // }

    // /// Arbitrary instance for the Result type.
    // instance Arbitrary[Result[e, t]] with Arbitrary[e], Arbitrary[t] {
    //     pub def arbitrary(): Gen[Result[e, t], r] =
    //         let func = (bool, eGen, tGen) ->
    //             match bool {
    //                 case true => Ok(tGen),
    //                 case false => Err(eGen)
    //             };
    //         map3(func, chooseBool(), Arbitrary.arbitrary(), Arbitrary.arbitrary())
    // }

    instance Arbitrary[Array[a, r]] with Arbitrary[a] {
        pub def arbitrary(): Gen[Array[a, r], r] =
            Gen.Gen(size -> rc -> _ ->
                Array.empty(rc, size)
            )
            // Functor.map(l -> List.toArray(rc, l), vector(5, rc))
            
            
    }
}