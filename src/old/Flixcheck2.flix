mod FlixCheck2 {
    pub type alias Rand = Int32

    pub enum Gen[a](Int32 -> Rand -> a)

    ///
    /// Applies a generator `gen` to a random number `r` and returns the generated value.
    ///
    /// `gen` the generator to apply.
    ///
    /// `r` the random number.
    ///
    /// `size` the size of the generated value.
    ///
    /// returns the generated value.
    ///
    pub def applyGen(gen: Gen[a], size: Int32, r: Rand): a =
        match gen {
            case Gen.Gen(f) => f(size, r)
        }

    /// Returns a generator that generates a value of type `a` in the interval size defines.
    pub def sized(f: Int32 -> Gen[a]): Gen[a] =
        Gen.Gen(size -> rand ->
            applyGen(f(size), size, rand)
        )

    /// Makes sure that the generator uses the specified size.
    /// 
    /// Takes as input size and generator of type `a`.     
    ///
    /// Returns a generator that generates a value of type `a`.
    pub def resize(size: Int32, gen: Gen[a]): Gen[a] =
        Gen.Gen(_ -> rand -> 
            applyGen(gen, size, rand)
        )

    /// Returns a generator that generates a random number.
    pub def rand(): Gen[Rand] = 
        Gen.Gen(_ -> rand -> rand)
 
    ///
    /// Promotes a function `f` of type `a -> Gen[b]` to a generator of functions of type `a -> b`.
    /// 
    /// `f` The function to promote.
    ///
    /// Returns a generator of functions of type `a -> b`.
    ///
    pub def promote(f: a -> Gen[b]): Gen[a -> b] =
        Gen.Gen(size -> rand ->
            a -> let gen = f(a); 
            applyGen(gen, size, rand)
        )

    pub def variant(v: Int32, gen: Gen[a]): Gen[a] =
        Gen.Gen(size -> rand ->
            let Gen.Gen(f) = gen;
            f(size, rands(rand, Int32.abs(v) + 1))
        )

    pub def rands(rand: Rand, v: Int32): Rand =
        let (r1, r2) = splitRand(rand);
        match v {
            case 0 => r1
            case n => rands(r2, n - 1)
        }

    /// Applies a function `f` to each value generated by `aGen`.
    ///
    /// Returns a new generator that produces the transformed values.
    ///
    /// `f` is the function to apply to each generated value.
    ///
    /// `aGen` is the generator for the input values.
    ///
    /// returns a new generator that produces the transformed values.
    ///
    pub def fmap(f: a -> b, aGen: Gen[a]): Gen[b] =
        bind(x -> return(f(x)), aGen)

    /// Returns a generator that generates a value of the given type
    pub def return(x: a): Gen[a] = 
        Gen.Gen(_ -> _ -> x)

    ///
    /// Binds a generator function `f` to a generator `aGen`.
    /// 
    /// `f` is the generator function that takes a value of type `a` and returns a generator of type `b`.
    ///
    /// `aGen` the generator of type `a`.
    ///
    /// Returns a generator of type `b` obtained by applying `f` to values generated by `aGen`.
    ///
    pub def bind(f: a -> Gen[b], aGen: Gen[a]): Gen[b] =
        Gen.Gen(size -> rand ->
            let (r1, r2) = splitRand(rand);
            let bGen = f(applyGen(aGen, size, r1));
            applyGen(bGen, size, r2)
        )
        
    /// Returns a generator that generates a value of type `a` from the given non-empty list of generators.
    pub def elements(xs: Nel[a]): Gen[a] =
        let vec = Nel.toVector(xs);
        fmap(index -> Vector.get(index, vec), chooseInt(0, Vector.length(vec) - 1))
   
    /// Returns a generator that generates a list of values of type `a` of length `n`.
    ///
    /// `n` is the length of the list.
    pub def vector(n: Int32): Gen[List[a]] with Arbitrary[a] =
        let gens: List[Gen[a]] = List.map(_ -> Arbitrary.arbitrary(), List.range(0, n));
        sequence(gens)

    /// Returns a generator that generates a list of values of type `a` 
    pub def sequence(gens: List[Gen[a]]): Gen[List[a]] =
        match gens {
            case Nil => 
                return(Nil)
            case head :: tail => 
                let func = x -> fmap(y -> x :: y, sequence(tail));
                bind(func, head)
        }

    /// Returns a generator that generates a list of length `length` with values of type `a`.
    pub def sizedListOf(length: Int32, gen: Gen[a]): Gen[List[a]] =
        match length {
            case 0 => 
                return(Nil)
            case _ => 
                let func = x -> fmap(y -> x :: y, sizedListOf(length - 1, gen));
                bind(func, gen)
        }

        
    /// Returns a generator that generates a value of type `a` from the given non-empty list of generators.
    pub def oneOf(gens: Nel[Gen[a]]): Gen[a] =
        bind(x -> x, elements(gens))


    /// Returns a randomly generated value of type `a` based on the given frequencies.
    ///
    /// `xs`: A non-empty list of pairs, where each pair consists of an integer frequency and a generator for values of type `a`.
    ///
    /// Returns a generator of type `a`.
    pub def frequency(xs: Nel[(Int32, Gen[a])]): Gen[a] =
        let total = Nel.foldLeft((acc, x) -> acc + fst(x), 0, xs);
        bind(x -> pick(x, xs), chooseInt(1, total))

    ///
    /// Returns a randomly generated value of type `a` based on the given frequency distribution.
    ///
    /// `n` is the number used to select a generator based on its frequency.
    ///
    /// `nel` is the non-empty list of tuples containing frequencies and generators.
    ///
    /// Returns a randomly generated value of type `a`.
    ///
    pub def pick(n: Int32, nel: Nel[(Int32, Gen[a])]): Gen[a] =
        match nel {
            case Nel.Nel((k, gen), _) if (n <= k) => 
                gen,
            case Nel.Nel((k, _), y :: ys) =>
                pick(n-k, Nel.Nel(y, ys))
            case Nel.Nel((_, _), Nil) =>
                // This should never happen as the sum of all frequencies are equal to n.
                unreachable!()
        }
    
    /// Lifts a function with 2 parameters to a monadic context
    pub def liftM2(f: a -> b -> c, aGen: Gen[a], bGen: Gen[b]): Gen[c] =
        let func = x -> fmap(y -> f(x, y), bGen);
        bind(func, aGen)

    /// Lifts a function with 3 parameters to a monadic context
    pub def liftM3(f: a -> b -> c -> d, aGen: Gen[a], bGen: Gen[b], cGen: Gen[c]): Gen[d] =
        let func = x -> liftM2(f(x), bGen, cGen);
        bind(func, aGen)
    
    /// Lifts a function with 4 parameters to a monadic context
    pub def liftM4(f: a -> b -> c -> d -> e, aGen: Gen[a], bGen: Gen[b], cGen: Gen[c], dGen: Gen[d]): Gen[e] =
        let func = x -> liftM3(f(x), bGen, cGen, dGen);
        bind(func, aGen)

    /// Returns a Generator that uniformly generates values in the interval [lower, upper]
    pub def chooseInt(lower: Int32, upper: Int32): Gen[Int32] = 
        let f = rand -> (Int32.abs(Int32.remainder(rand, (upper + 1) - lower)) + lower);
        fmap(f, rand())

    /// Returns a generator that uniformly generates a boolean value.
    pub def chooseBool(): Gen[Bool] =
        elements(Nel.Nel(true, false :: Nil))

    /// Returns a generator that uniformly generates a float value in the interval [lower, upper]
    pub def chooseFloat(lower: Int32, upper: Int32): Gen[Float32] =
        let func = (int, quotient) -> (
            let number = Int32.toFloat32(int);
            let fraction = Int32.toFloat32(quotient)/Int32.toFloat32(Int32.maxValue());
            number + fraction
        );
        liftM2(func, chooseInt(lower, upper - 1), chooseInt(0, Int32.maxValue()))


    /// Returns a generator that uniformly generates a lower case character.
    pub def chooseLowerChar(): Gen[Char] =
        elements(Nel.Nel('a', 
        'b' :: 'c' :: 'd' :: 'e' :: 'f' :: 'g' :: 'h' :: 
        'i' :: 'j' :: 'k' :: 'l' :: 'm' :: 'n' :: 'o' :: 
        'p' :: 'q' :: 'r' :: 's' :: 't' :: 'u' :: 'v' :: 
        'w' :: 'x' :: 'y' :: 'z' :: Nil))


    /// Returns a generator that uniformly generates an upper case character.
    pub def chooseUpperChar(): Gen[Char] =
        elements(Nel.Nel('A', 
        'B' :: 'C' :: 'D' :: 'E' :: 'F' :: 'G' :: 'H' ::
        'I' :: 'J' :: 'K' :: 'L' :: 'M' :: 'N' :: 'O' ::
        'P' :: 'Q' :: 'R' :: 'S' :: 'T' :: 'U' :: 'V' ::
        'W' :: 'X' :: 'Y' :: 'Z' :: Nil))


    // Arbitrary trait
    pub trait Arbitrary[a] {
        pub def arbitrary(): Gen[a]
        pub def coArbitrary(x: a): Gen[b] -> Gen[b]
    }

    // Arbitrary instances
    instance Arbitrary[Unit] {
        pub def arbitrary(): Gen[Unit] =
            return()

        pub def coArbitrary(_: Unit): Gen[b] -> Gen[b] = 
            variant(0)
    }

    instance Arbitrary[Bool] {
        pub def arbitrary(): Gen[Bool] =
            chooseBool()

        pub def coArbitrary(b: Bool): Gen[b] -> Gen[b] = 
            match b {
                case true => variant(0),
                case false => variant(1)
            }
    }

    instance Arbitrary[Int32] {
        pub def arbitrary(): Gen[Int32] =
            sized(size -> chooseInt(-size, size))

        pub def coArbitrary(n: Int32): Gen[b] -> Gen[b] =
            match n {
                case _ if n >= 0 => variant(2*n),
                case _ if n < 0 => variant(2*(-n) + 1)
                case _ => unreachable!()
            }

    }

    instance Arbitrary[Char] {
        pub def arbitrary(): Gen[Char] = 
            chooseUpperChar()

        pub def coArbitrary(x: Char): Gen[b] -> Gen[b] = 
            ???
    }

    instance Arbitrary[Float32] {
        pub def arbitrary(): Gen[Float32] = 
            sized(size -> chooseFloat(-size, size))

        pub def coArbitrary(x: Float32): Gen[b] -> Gen[b] = ???
    }

    instance Arbitrary[(a, b)] with Arbitrary[a], Arbitrary[b] {
        pub def arbitrary(): Gen[(a, b)] =
            liftM2((x, y) -> (x, y), Arbitrary.arbitrary(), Arbitrary.arbitrary())

        pub def coArbitrary(x: (a, b)): Gen[c] -> Gen[c] = ???
    }

    instance Arbitrary[(a, b, c)] with Arbitrary[a], Arbitrary[b], Arbitrary[c] {
        pub def arbitrary(): Gen[(a, b, c)] =
            liftM3((x, y, z) -> (x, y, z), Arbitrary.arbitrary(), Arbitrary.arbitrary(), Arbitrary.arbitrary())

        pub def coArbitrary(x: (a, b, c)): Gen[d] -> Gen[d] = ???
    }

    instance Arbitrary[(a, b, c, d)] with Arbitrary[a], Arbitrary[b], Arbitrary[c], Arbitrary[d] {
        pub def arbitrary(): Gen[(a, b, c, d)] =
            liftM4((x, y, z, w) -> (x, y, z, w), Arbitrary.arbitrary(), Arbitrary.arbitrary(), Arbitrary.arbitrary(), Arbitrary.arbitrary())

        pub def coArbitrary(x: (a, b, c, d)): Gen[e] -> Gen[e] = ???
    }

    instance Arbitrary[List[a]] with Arbitrary[a] {
        pub def arbitrary(): Gen[List[a]] =
            sized(size -> 
                bind(n -> vector(n), chooseInt(0, size))
            )

        pub def coArbitrary(xs: List[a]): Gen[b] -> Gen[b] = ???
    }

    instance Arbitrary[Nel[a]] with Arbitrary[a] {
        pub def arbitrary(): Gen[Nel[a]] =
            sized(size ->
                liftM2((x, xs) -> Nel.Nel(x, xs), Arbitrary.arbitrary(), vector(size - 1))
            )

        pub def coArbitrary(xs: Nel[a]): Gen[b] -> Gen[b] = ???
    }

    instance Arbitrary[Chain[a]] with Arbitrary[a] {
        pub def arbitrary(): Gen[Chain[a]] =
            sized(size -> 
                fmap(l -> List.toChain(l), vector(size))
            )

        pub def coArbitrary(xs: Chain[a]): Gen[b] -> Gen[b] = ???
    }

    instance Arbitrary[Nec[a]] with Arbitrary[a] {
        pub def arbitrary(): Gen[Nec[a]] =
            sized(size ->
                let func = (x, xs) -> 
                    match List.toNec(xs) {
                        case None => Nec.singleton(x),
                        case Some(tail) => Nec.append(Nec.singleton(x), tail)
                    };
                liftM2(func, Arbitrary.arbitrary(), vector(size - 1))
            )

        pub def coArbitrary(xs: Nec[a]): Gen[b] -> Gen[b] = ???
    }

    instance Arbitrary[Vector[a]] with Arbitrary[a] {
        pub def arbitrary(): Gen[Vector[a]] =
            sized(size -> 
                fmap(l -> List.toVector(l), vector(size))
            )

        pub def coArbitrary(xs: Vector[a]): Gen[b] -> Gen[b] = ???
    }

    instance Arbitrary[Option[a]] with Arbitrary[a] {
        pub def arbitrary(): Gen[Option[a]] = 
            let func = (bool, arb) -> 
                match bool {
                    case true => Some(arb),
                    case false => None
                };
            liftM2(func, chooseBool(), Arbitrary.arbitrary())

        pub def coArbitrary(x: Option[a]): Gen[b] -> Gen[b] = ???
    }

    instance Arbitrary[Result[e, t]] with Arbitrary[e], Arbitrary[t] {
        pub def arbitrary(): Gen[Result[e, t]] =
            let func = (bool, eGen, tGen) ->
                match bool {
                    case true => Ok(tGen),
                    case false => Err(eGen)
                };
            liftM3(func, chooseBool(), Arbitrary.arbitrary(), Arbitrary.arbitrary())

        pub def coArbitrary(x: Result[e, t]): Gen[b] -> Gen[b] = ???
    }
}