mod GenTest {
    use SplittableRandom.{split, nextBool, nextInt32, nextFloat64}

    pub type alias Rand = SplittableRandom

    pub enum Gen[a: Type, r: Region](
        Int32 -> Region[r] -> Rand[r] -> a \ r
    )

    pub trait Functor[m: Type -> Eff -> Type] {
        pub def map(f: a -> b \ ef, x: m[a, r]): m[b, r] \ ef
    }

    pub trait Applicative[m: Type -> Eff -> Type] with Functor[m] {
        pub def ap(f: m[a -> b \ ef, r], x: m[a, r]): m[b, r] \ ef
        pub def point(x: a): m[a, r]
    }

    pub trait Monad[m: Type -> Eff -> Type] with Applicative[m] {
        pub def flatMap(f: a -> m[b, r] \ ef, x: m[a, r]): m[b, r] \ ef
    }

    instance Functor[Gen] {
        pub def map(f: a -> b \ ef, gen: Gen[a, r]): Gen[b, r] \ ef =
            checked_ecast(Gen.Gen(size -> rc -> rand -> 
                unchecked_cast(f(applyGen(gen, size, rc, rand)) as _ \ r)))
    }

    instance Applicative[Gen] {
        /// Returns a generator that generates a value of type `b` by applying the function generated by `fGen` to the value generated by `aGen`.
        pub def ap(fGen: Gen[a -> b \ ef, r], aGen: Gen[a, r]): Gen[b, r] \ ef = 
            checked_ecast(Gen.Gen(size -> rc -> rand ->
                let (r1, r2) = split(rand); 
                let func = applyGen(fGen, size, rc, r1);
                unchecked_cast(func(applyGen(aGen, size, rc, r2)) as _ \ r)))
        
        /// Returns a generator that generates a value of the given type
        pub def point(x: a): Gen[a, r] = 
            return(x)
    }

    instance Monad[Gen] {
        pub def flatMap(f: a -> Gen[b, r] \ ef, aGen: Gen[a, r]): Gen[b, r] \ ef =             
            checked_ecast(Gen.Gen(size -> rc -> rand -> 
                let (r1, r2) = split(rand);
                unchecked_cast(
                    let Gen.Gen(func) = f(applyGen(aGen, size, rc, r1));
                    func(size, rc, r2) as _ \ r))
            )
    }

    pub def return(x: a): Gen[a, r] = 
        Gen.Gen(_ -> _ -> _ -> unchecked_cast(x as _ \ r))

    pub def applyGen(gen: Gen[a, r], size: Int32, rc: Region[r], rand: Rand[r]): a \ {r} =
        match gen {
            case Gen.Gen(g) => g(size, rc, rand)
        }

    pub def chooseInt(lower: Int32, upper: Int32): Gen[Int32, r] =
        Gen.Gen(_ -> _ -> rand ->
            nextInt32(rand, lower, upper + 1)
        )

    pub def sizedListOf(length: Int32, gen: Gen[a, r]): Gen[List[a], r] =
        let gens: List[Gen[a, r]] = List.map(_ -> gen, List.range(0, length));
        sequence(gens)
        
    pub def sequence(l: List[Gen[a, r]]): Gen[List[a], r] =
        def loop(ll, k) = match ll {
            case Nil => k(Applicative.point(Nil)),
            case mx :: rs => loop(rs, ks -> k(consA(mx, ks)))
        };
        loop(l, identity)
        
    pub def consA(mx: Gen[a, r], ml: Gen[List[a], r]): Gen[List[a], r] =
        Applicative.ap(Functor.map((x, xs) -> x :: xs, mx), ml)  

    pub trait Arbitrary[a] {
        pub def arbitrary(): Gen[a, r]
    }

    instance Arbitrary[Int32] {
        pub def arbitrary(): Gen[Int32, r] = 
            Gen.Gen(_ -> _ -> rand -> SplittableRandom.nextInt32(rand, 5, 6))
    }

    instance Arbitrary[List[a]] with Arbitrary[a] {
        pub def arbitrary(): Gen[List[a], r] =
            sizedListOf(5, Arbitrary.arbitrary())
    }

    // instance Arbitrary[Array[a, r1]] with Arbitrary[a] {
    //     pub def arbitrary(): Gen[Array[a, r2], r2] = 
    //         Gen.Gen(_ -> rc -> _ ->
    //                 Array.empty(rc, 5)
    //         )
    // }
        
}